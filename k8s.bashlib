#!/bin/echo 'This script cannot be executabled directly. Please source from another script'

export GRAFANA_VERSION="8.5.2"
export K8S_VERSION="1.23"
export KUBERNETES_DASHBOARD_VERSION="2.5.1"
export K8S_NODES=( 's1.ubuntu.home' 's5.ubuntu.home' 's6.ubuntu.home' 's7.ubuntu.home' 's8.ubuntu.home' )
export SNAP='/var/snap/microk8s/current'

#----------------------------------------------------------------------------------------------
#  functions for 'k8s.app'
#---------------------------------------------------------------------------------------------- 

function k8s.__init() {

    # shellcheck disable=SC2034
    START=$(date +%s)

    # Use the Unofficial Bash Strict Mode
    set -o errexit
    set -o nounset
    set -o pipefail
    IFS=$'\n\t'

    # declarations of MUST HAVE globals
    # shellcheck disable=SC2034
    PROGRAM_DIR="${PROGRAM_DIR:-~/GIT/k8s}"
    BASHLIB_DIR="${BASHLIB_DIR:-~/.bin/utilities/bashlib}"
    PROGRAM_NAME="$(basename "${BASH_SOURCE[0]}" | sed 's|.sh$||')"
    # shellcheck disable=SC2034
    LOGFILE="$(pwd)/${PROGRAM_NAME}.log"
    # shellcheck disable=SC2034
    JSONNET_IMAGE='s2.ubuntu.home:5000/thirdparty/jsonnet:0.18.0-debian-10-r84'

    # source other bashlibs

    # shellcheck disable=SC1090
    source "${BASHLIB_DIR}/trap.bashlib"
    # shellcheck disable=SC1090
    source "${BASHLIB_DIR}/timer.bashlib"
    trap k8s.onexit EXIT

    # shellcheck disable=SC2034
    DEBUG=0
    LASTTIME="$START"

    [ -z "${KUBECTL:-}" ] && KUBECTL="microk8s.kubectl"
    :> 'elapsed.times.txt'
}

# ----------------------------------------------------------------------------------- 
function k8s.add_new_content() {

    local -a apps=( 'hubot' 'jenkins' 'kowl' 'recipes' 'smee' 'versions' 'web' 'zoonavigator' "microk8s.${K8S_VERSION}" 'prometheus' )

    echo 'adding new content'
    for app in "${apps[@]}"; do
        k8s.run "$KUBECTL" create -f "production/${app}/" 
        sleep 30  # wait for initialization to complete 
    done

    k8s.logElapsed "${FUNCNAME[0]}"
}

# -----------------------------------------------------------------------------------
function k8s.add_nodes_to_cluster() {

    echo 'join nodes into cluster'
    local cmd h ip
    
    # get our local ip4 address
    ip="$(ip -4 -j address show scope global dynamic|jq -r '.[0].addr_info[].local')" 

    # add nodes to cluster
    for h in s1.ubuntu.home s{6..8}.ubuntu.home; do
        cmd="$(sudo microk8s add-node | grep "$ip" | head -1)"
        echo "ssh $h '$cmd'"
        k8s.run ssh "$h" "$cmd"
        k8s.run ssh "$h" "microk8s status --wait-ready"
    done

    k8s.logElapsed "${FUNCNAME[0]}"
}

# -----------------------------------------------------------------------------------
function k8s.capture_config() {

    echo 'capturing config content'
    "$KUBECTL" api-versions ||: > ./api-api-versions.txt
    "$KUBECTL" api-resources -o wide ||: > ./api-resources.txt

    k8s.logElapsed "${FUNCNAME[0]}"
}

# -----------------------------------------------------------------------------------
function k8s.capture_ips_for_gui() {

   local ipFile='services_ips.json'

    echo 'capturing IPs for GUI'
    "$KUBECTL" get services -A -o json |  jq '[.items[]|select(.spec.clusterIP != "None")|{"title":.metadata.name, "host": .spec.clusterIP, "port":.spec.ports[0].port}]' > "$ipFile"
    scp "$ipFile" s3:production/workspace.production/www/
#    cp "$ipFile" /mnt/k8s/web/

    k8s.logElapsed "${FUNCNAME[0]}"
}

# -----------------------------------------------------------------------------------
function k8s.capture_status() {

    echo 'capturing status'
    sudo snap alias microk8s-kubectl kubectl
    k8s.run "$KUBECTL" cluster-info
    k8s.run "$KUBECTL" get nodes
    k8s.run "$KUBECTL" get all -A

#    k8s.dump_apis

    k8s.logElapsed "${FUNCNAME[0]}"
}

# -----------------------------------------------------------------------------------
function k8s.createApp() {

    [ "$#" -eq 0 ] && return 0
    local dir
    for dir in "$@"; do
        k8s.load_namespace "$dir"
    done
} 

# -----------------------------------------------------------------------------------
function k8s.createSecretsForApp() {

    local -r target="${1:?}"
    local -r certs="${2:-certs}"

    [[ -e "$certs" && -e "$certs" ]] || return 0
    local name    
    while read -r file; do
        name="$(echo "${target,,}${file//$certs/}" | sed -e 's|[/\.]|-|g')"
        "$KUBECTL" create secret generic "$name" --dry-run=client --from-file="$file" -o yaml > "${target}/02.Secret.${name}.yaml"
    done < <(find "$certs" -mindepth 1 -maxdepth 1 -type f)
}

# -----------------------------------------------------------------------------------
function k8s.customize_content() {

    echo 'customizing content'
    k8s.run "$KUBECTL" apply -f ./production/corends.ConfigMap.yml
    k8s.run "$KUBECTL" apply -f ./production/nginx-ingress.DaemonSet.yml

    local ns object
    while read -r patchFile;do
        # extract namespace from patchFile name
        ns="$(basename "${patchFile}")"
        ns="${ns%%.*}"
        # extract obect from patchFile name
        object="$(basename "${patchFile%.*}")"
        object="${object#*.}"
        object="${object//.//}"
        # patch object
        k8s.run "$KUBECTL" patch "$object" -n "$ns" --patch-file=<(envsubst < "$patchFile") --type='merge'
    done < <(find "production/patches.${K8S_VERSION}" -mindepth 1 -maxdepth 1 -type f -name '*.json') 

    k8s.logElapsed "${FUNCNAME[0]}"
}

# -----------------------------------------------------------------------------------
function k8s.dump_apis() {

   local -r dir_org="${1:-by_api}"

    local mode object
    local -a modes=('wide' 'json' 'yaml')

    mkdir -p apis
    rm -rf apis/*

    if [ "$dir_org" != 'by_api' ]; then
        for mode in "${modes[@]}"; do
            mkdir -p "apis/$mode"
        done
    fi
    while read -r object; do
        echo "  $object"
        [ "$dir_org" = 'by_api' ] && mkdir -p "apis/${object}"
        for mode in "${modes[@]}"; do
            declare ext="$mode"
            [ "$mode" = 'wide' ] && ext='txt'
            if [ "$dir_org" = 'by_api' ]; then
                "$KUBECTL" get "$object" -A -o "$mode" &> "apis/${object}/${mode}.$ext" ||:
            else
                "$KUBECTL" get "$object" -A -o "$mode" &> "apis/${mode}/${object}.$ext" ||:
            fi
        done
    done < <("$KUBECTL" api-resources --no-headers=false -o=name --sort-by=name)

    "$KUBECTL" api-resources --sort-by=name --output wide > apis/api-resourses.txt

    k8s.logElapsed "${FUNCNAME[0]}"
}

# -----------------------------------------------------------------------------------
function k8s.enable_microk8s_modules() {

    echo 'enable microk8s modules'
    local -a modules
    case "$K8S_VERSION" in
      1.23)  modules=( 'ingress' 'dns' 'fluentd' 'storage' 'metallb:192.168.0.1-192.168.0.100' 'metrics-server' 'prometheus' 'dashboard' 'dashboard-ingress' 'helm3' ) ;;
      1.24)  modules=( 'ingress' 'dns' 'storage' 'hostpath-storage' 'metallb:192.168.0.1-192.168.0.100' 'metrics-server' 'prometheus' 'helm3' );;
      *)     retrn 1;;
    esac

    for module in "${modules[@]}";do 
        k8s.run sudo microk8s enable "$module" ||:
    done

    k8s.run microk8s status --wait-ready
    k8s.run sudo iptables --flush
    k8s.run sudo iptables -P FORWARD ACCEPT

    k8s.logElapsed "${FUNCNAME[0]}"
}


# -----------------------------------------------------------------------------------
function k8s.generate_token() {

    echo 'generating tokens.inf'
    local token_file='tokens.inf'
    :> "$token_file"
    for token in default-token admin-user ; do
        local ref="$("$KUBECTL" -n kube-system get secret | grep "$token" ||:)"
        [ "${ref:-}" ] && ref="$(awk '{print $1}' <<< "$ref")"
        # shellcheck disable=SC2181
        [[ "$?" != 0 || -z "${ref:-}" ]] && continue
        k8s.run "$KUBECTL" -n kube-system describe secret "$ref" | tee -a "$token_file"
        break
    done
    [ -s "$token_file" ] || rm "$token_file"

    k8s.logElapsed "${FUNCNAME[0]}"
}

# -----------------------------------------------------------------------------------
function k8s.installApp() {

    [ "$#" -eq 0 ] && return 0

    k8s.removeApp "$@"
    k8s.createApp "$@"
    "$KUBECTL" get all
} 

# ----------------------------------------------------------------------------------- 
# shellcheck disable=SC2120
function k8s.journalctl() {

    # shellcheck disable=SC2034
    for i in {1..4}; do
        [ "$(microk8s status)" == 'microk8s is not running. Use microk8s inspect for a deeper inspection.' ] || return 0
    done

    local -r identifier="${1:-microk8s.daemon-kubelite}"
    local -r start="${2:-$START}"
    local -r end="${3:-$(date +'%s')}"

    echo
    echo
    # shellcheck disable=SC2086
    echo "journalctl --reverse --output=verbose --identifier='${identifier}' --since $(date +'%Y-%m-%d %H:%M:%S' --date=@${start}) --until $(date +'%Y-%m-%d %H:%M:%S' --date=@${end})"
#    journalctl --reverse --output=verbose --identifier="${identifier}" --since "$(date +'%Y-%m-%d %H:%M:%S' --date=@"${start}")" --until "$(date +'%Y-%m-%d %H:%M:%S' --date=@"${end}")"
    journalctl --reverse --output=verbose --since "$(date +'%Y-%m-%d %H:%M:%S' --date=@"${start}")" --until "$(date +'%Y-%m-%d %H:%M:%S' --date=@"${end}")"
    exit 1
}

# -----------------------------------------------------------------------------------
function k8s.jsonnet() {

    [ "$#" -eq 0 ] && return 0
    export JSONNET_PATH="${JSONNET_PATH:-}:https://raw.eos2git.cec.lab.emc.com/TechOps/k8s-libsonnet/upstream-main/1.20/"
    local text="$(docker run --rm --tty --volume "$(pwd):$(pwd)" --workdir "$(pwd)" "$JSONNET_IMAGE" "$@")" ||:
    echo "$text"
}

# -----------------------------------------------------------------------------------
function k8s.load_namespace() {

    local -r dir="${1:?}"
    local -r verb="${2:-create}"

    local direction=''
    [ "$verb" = 'delete' ] && direction='-r'
    
    local file status
    while read -r file; do
        ("$KUBECTL" "$verb" -f "${file}") && status=$? || status=$?
        [ "$verb" = 'delete' ] && continue
        [ "${status:-0}" -ne 0 ] && exit
    done < <(find "production/${dir}" -type f | LC_ALL=C sort -n $direction)
    echo
    k8s.logElapsed "${FUNCNAME[0]}"
}

# -----------------------------------------------------------------------------------
function k8s.logElapsed() {

    [ "${DEBUG:-0}" -eq 0 ] && return 0
    k8s.journalctl

    local -r text="${1:-}"
    local current=$(timer.getTimestamp)

    {
        printf '%s %s %s\n' "$(date -Ins)" "$text" "$(timer.fmtElapsed "$((current - LASTTIME))")"
        echo
    } | tee -a elapsed.times.txt
    LASTTIME="$current"
    return 0
}

# -----------------------------------------------------------------------------------
function k8s.onexit() {

    find /tmp -maxdepth 1 -mindepth 1 -type f \( -name 'ssh.s?.txt' -or -name 'tmp*' \) -delete
    if [ "${REMOTE:-}" ]; then
        for h in s1.ubuntu.home s{5..8}.ubuntu.home; do
            # shellcheck disable=SC2029        
            ssh "$h" "[ -e '$REMOTE' ] && rm '$REMOTE'"
        done
    fi
    [ -f "${SCRIPT:-}" ] && rm "${SCRIPT}"

    local -i delta="$(timer.getTimestamp)"
    delta="$(( delta - START ))"
    [ "$delta" -lt 3 ] || printf '%s %s %s\n\n' "$(date -Ins)" 'Total Elapse time' "$(timer.fmtElapsed "$delta")" | tee -a elapsed.times.txt
}

# -----------------------------------------------------------------------------------
function k8s.onRemote() {
    
    cat << "EOF"
#!/bin/bash
function add_registries() {

    local host
    for host in "$@"; do
        cat << "REGISTRY"
       [plugins."io.containerd.grpc.v1.cri".registry.mirrors."${host}"]
         endpoint = ["http://${host}"]
REGISTRY
    done
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function create_registry_defs() {

    local SNAP_DATA="${1:-/etc/containerd/config.toml}"
    local version="${2:-}"
    local config_path="${SNAP_DATA}/args/certs.d"
    shift 2

    local host
    for host in "$@"; do
        local reg="http://${host}"
        run mkdir -p "${config_path}/$host"
        cat << REGISTRY > "${config_path}/${host}/hosts.toml"
server = "$reg"

[host."$reg"]
  capabilities = ["pull", "resolve"]
REGISTRY
    done
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function main() {

    START=$(date +%s)
    DEBUG=0
    BASHLIB_DIR='/home/bobb/.bin/utilities/bashlib'

    local -r host="${1:?}"
    local -r version="${2:?}"
    local -r user="${3:?}"
    local inf="$(getent passwd "$USER")"
    [ "${inf:-}" ] || return 1

    local -r uid="$(cut -d ':' -f 3 <<< "$inf")"
    local -r gid="$(cut -d ':' -f 4 <<< "$inf")"
    local -r homeDir="$(cut -d ':' -f 6 <<< "$inf")"
    local -r LOCAL_CONFIG="${homeDir}/.kube/config"

    echo "## $(date -Ins) ${host} ###########################################################################"

    # Use the Unofficial Bash Strict Mode
    set -o errexit
    set -o nounset
    set -o pipefail
    IFS=$'\n\t'
    source "${BASHLIB_DIR}/trap.bashlib"
    source "${BASHLIB_DIR}/timer.bashlib"
    trap onexit EXIT


#    microk8s disable ha-cluster --force ||:
    microk8s.reset --destroy-storage ||:
    run snap remove microk8s

    # create fresh dir for comfig
    [ -d "${homeDir}/.kube" ] && rm -rf "${homeDir}/.kube"
    sudo mkdir -p "${homeDir}/.kube"
    sudo chown -R "${uid}:${gid}" "${homeDir}/.kube"

    run snap install microk8s --channel "${version}/stable" --classic

    if [ -e "${SNAP}/credentials/client.config" ]; then
        run cp "${SNAP}/credentials/client.config" "$LOCAL_CONFIG"
    else
        run microk8s config > "$LOCAL_CONFIG"
    fi

    if [[ "$(pwd)" =~ '/home/bobb' ]]; then
        local -r CONFIG_FILE="$(pwd)/config.home"
        [ -e "$CONFIG_FILE" ] && cp "$LOCAL_CONFIG" "$CONFIG_FILE"
    fi

    echo 'add user to microk8s group'
    run sudo usermod -a -G microk8s "$user"


    echo 'update k8s config and registry settings'
    run microk8s stop
    echo 'add home to csr.conf.template'
    sed -i -e '/cluster.local/aDNS.6 = home' "${SNAP}/certs/csr.conf.template"

    local -a registries
    mapfile -t registries < <(nslookup s2.ubuntu.home | awk '{if((NR==5 && match($1,"^Name")>0)||(NR != 2 && match($1,"^Address")>0)){print $2 ":5000"}}')
    if [ "${version/./}" -ge '123' ]; then
        echo "create_registry_defs for ${version}"
        run create_registry_defs "$SNAP" "${version}" "${registries[@]}"
    else
        echo "add_registries for ${version}"
        run add_registries "${version}" "${registries[@]}" >> "${SNAP}/args/containerd-template.toml"
    fi

    run microk8s start

#    run microk8s refresh-certs --certs ca.crt

    echo 'waiting for K8s to be ready'
    run microk8s status --wait-ready
    echo "## $(date -Ins) ${host} ##################################################################### END #"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function onexit() {

    [ "${DEBUG:-0}" -eq 0 ] && return 0

    local current=$(timer.getTimestamp)
    local -i elapsed=$((current - START)) 
    printf '%s Elapsed time: %s\n' "$(date -Ins)" "$(timer.fmtElapsed $elapsed)" 
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
function run() {
  {
      echo
      printf '\e[90m%s\e[0m ' "$@"
      echo
  } >&2
  "$@"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
EOF
    # start new HEREDOC with substitution
    cat << EOF
SCRIPT="\$0"
SNAP="$SNAP"
main "\$(hostname)" "$K8S_VERSION" "$USER"
EOF
}

# -----------------------------------------------------------------------------------
function k8s.removeApp() {

    [ "$#" -eq 0 ] && return 0
    local dir
    for dir in "$@"; do
        k8s.createSecretsForApp "$dir"
        k8s.load_namespace "$dir" 'delete'
    done
}

# -----------------------------------------------------------------------------------
function k8s.reinit_nodes() {

    SCRIPT="$(mktemp)"
    k8s.onRemote > "$SCRIPT"

    echo 'reinit each node'

    REMOTE='/tmp/reinit'
    function reinstall.remote() {

        local -r h="${1:?}"

        printf '%s starting %s\n' "$(date -Ins)" "$h"
        k8s.run scp "$SCRIPT" "$h:$REMOTE"
        # shellcheck disable=SC2029        
        ssh "$h" "chmod 755 '$REMOTE'"
        # shellcheck disable=SC2029        
        k8s.run ssh "$h" "sudo '$REMOTE'"
        k8s.logElapsed "${h}"
        # shellcheck disable=SC2029        
        ssh "$h" "[ -e '$REMOTE' ] && rm '$REMOTE'"
    }

    k8s.runInParallel 'reinstall.remote' "${K8S_NODES[@]}"
    rm "$SCRIPT"
    DEBUG=1

    k8s.logElapsed "${FUNCNAME[0]}"
}

# -----------------------------------------------------------------------------------
function k8s.reinstall_cluster() {

    :> elapsed.times.txt

    sudo usermod -a -G microk8s "$USER"

    k8s.reinit_nodes
    k8s.add_nodes_to_cluster
    k8s.set_config
    k8s.enable_microk8s_modules
exit
    k8s.customize_content
    k8s.add_new_content
    k8s.generate_token
    k8s.capture_config
    k8s.capture_ips_for_gui
    k8s.capture_status
}

# -----------------------------------------------------------------------------------
function k8s.remove_content() {

    echo 'removing content'
    k8s.run "$KUBECTL" apply -f ./production/corends.ConfigMap.yml
    k8s.run "$KUBECTL" apply -f ./production/nginx-ingress.DaemonSet.yml

    k8s.load_namespace 'grafana' 'apply'
    k8s.load_namespace 'kubernetes-dashboard' 'apply'

    (k8s.load_namespace 'hubot' 'delete') ||:
    (k8s.load_namespace 'jenkins' 'delete') ||:
    (k8s.load_namespace 'kowl' 'delete') ||:
    (k8s.load_namespace 'recipes' 'delete') ||:
    (k8s.load_namespace 'smee' 'delete') ||:
    (k8s.load_namespace 'versions' 'delete') ||:

    k8s.logElapsed "${FUNCNAME[0]}"
}

# -----------------------------------------------------------------------------------
function k8s.run() {
  {
      echo
      printf '\e[90m%s\e[0m ' "$@"
      echo
  } >&2
  "$@"
}

# -----------------------------------------------------------------------------------
function k8s.runInParallel() {

    local script="${1:?}"
    shift

    echo "start $# copies of $script"
    for h in "$@"; do
      ( k8s.run "$script" "$h" ) &> "/tmp/$h.log" &
    done

    echo '  wait for all jobs to complete'
    while [ "$(jobs -r -p)" ]; do
        wait
    done

    echo '  output log of each job'
    for h in "$@"; do
        [ -e "/tmp/$h.log" ] || continue
        cat "/tmp/$h.log"
        rm "/tmp/$h.log"
    done
    k8s.logElapsed "${FUNCNAME[0]}"
}

# -----------------------------------------------------------------------------------
function k8s.set_config() {

    echo 'setting kubectl config'
    local -r HOST="$(hostname -f)"
    local -r CONFIG_FILE="$(pwd)/config.home"

    local -r inf="$(getent passwd "$USER")"
    local -r uid="$(cut -d ':' -f 3 <<< "$inf")"
    local -r gid="$(cut -d ':' -f 4 <<< "$inf")"
    local -r homeDir="$(cut -d ':' -f 6 <<< "$inf")"
    local -r LOCAL_CONFIG="${homeDir}/.kube/config"

    sudo mkdir -p "${homeDir}/.kube"
    sudo chown -f -R "${uid}:${gid}" "${homeDir}/.kube"

    if [ -e "${SNAP}/credentials/client.config" ]; then
        k8s.run cp "${SNAP}/credentials/client.config" "$LOCAL_CONFIG"
    else
        k8s.run microk8s config > "$LOCAL_CONFIG"
    fi
    sed -i -e "s|127.0.0.1|$(ip -4 -j address show scope global dynamic|jq -r '.[0].addr_info[].local')|g" "$LOCAL_CONFIG"
    cp "$LOCAL_CONFIG" "$CONFIG_FILE"

    function set_k8s_config() {
        local -r h="${1:?}"
        echo "setting k8s config on $h"
        mkdir -p "${homeDir}/.kube"
        scp "${HOST}:$CONFIG_FILE" "${homeDir}/.kube/config"
        sudo chown -R "${uid}:${gid}" "${homeDir}/.kube"
        sudo usermod -a -G microk8s "$(getent passwd "$uid"|cut -d ':' -f 1)"
    }

    k8s.runInParallel 'set_k8s_config' "${K8S_NODES[@]}" 's3.ubuntu.home' 's4.ubuntu.home'

    k8s.logElapsed "${FUNCNAME[0]}"
}

# -----------------------------------------------------------------------------------
